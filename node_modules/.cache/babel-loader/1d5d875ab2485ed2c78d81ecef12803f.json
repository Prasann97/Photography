{"ast":null,"code":"function _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nimport { handleOffset } from '../Calendar/utils'; // Converting between Date and String types is handled via a \"schema\".\n// The schema is an array of strings, split into strings with identical\n// characters. So, 'mm/dd/yyyy' will be ['mm', '/', 'dd', '/', 'yyyyy'].\n\nexport var formatToSchema = function formatToSchema(format) {\n  if (!format) return undefined;\n  var result = [];\n  var i = 0;\n  var part;\n\n  while (i < format.length) {\n    if (!part || part[0] !== format[i]) {\n      if (part) result.push(part);\n      part = format[i];\n    } else {\n      part += format[i];\n    }\n\n    i += 1;\n  }\n\n  if (part) result.push(part);\n  return result;\n};\nvar masks = {\n  m: {\n    length: [1, 2],\n    regexp: /^[1-9]$|^1[0-2]$/\n  },\n  mm: {\n    length: [1, 2],\n    regexp: /^[0-1]$|^0[1-9]$|^1[0-2]$/\n  },\n  d: {\n    length: [1, 2],\n    regexp: /^[1-9]$|^[1-2][0-9]$|^3[0-1]$/\n  },\n  dd: {\n    length: [1, 2],\n    regexp: /^[0-3]$|^0[1-9]$|^[1-2][0-9]$|^3[0-1]$/\n  },\n  yy: {\n    length: [1, 2],\n    regexp: /^[0-9]{1,2}$/\n  },\n  yyyy: {\n    length: [1, 4],\n    regexp: /^[0-9]{1,4}$/\n  }\n};\nexport var schemaToMask = function schemaToMask(schema) {\n  if (!schema) return undefined;\n  return schema.map(function (part) {\n    var lower = part.toLowerCase();\n    var _char = lower[0];\n    if (_char === 'm' || _char === 'd' || _char === 'y') return _extends({\n      placeholder: part\n    }, masks[lower]);\n    return {\n      fixed: part\n    };\n  });\n}; // convert value into text representation using the schema\n\nexport var valueToText = function valueToText(value, schema) {\n  var text = ''; // when user initializes dates as empty array, we want to still\n  // show the placeholder text\n\n  if (!value || Array.isArray(value) && !value.length) return text;\n  var dates = (Array.isArray(value) ? value : [value]).map(function (v) {\n    // TO DO should we extract this to a reusable function?\n    var adjustedDate = new Date(v); // if time is not specified in ISOstring, normalize to midnight\n\n    if (v.indexOf('T') === -1) {\n      var offset = adjustedDate.getTimezoneOffset();\n      var hour = adjustedDate.getHours();\n      adjustedDate.setHours(hour, offset);\n    }\n\n    return adjustedDate;\n  });\n  var dateIndex = 0;\n  var parts = {};\n  schema.every(function (part) {\n    var _char2 = part[0].toLowerCase(); // advance dateIndex if we already have this part\n\n\n    while (dateIndex < dates.length && (Number.isNaN(dates[dateIndex].date) || (_char2 === 'm' || _char2 === 'd' || _char2 === 'y') && parts[part])) {\n      dateIndex += 1;\n      parts = {};\n    }\n\n    var date = dates[dateIndex];\n\n    if (date && part === 'm') {\n      text += date.getMonth() + 1;\n      parts[part] = true;\n    } else if (date && part === 'mm') {\n      text += (\"0\" + (date.getMonth() + 1)).slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'd') {\n      text += date.getDate();\n      parts[part] = true;\n    } else if (date && part === 'dd') {\n      text += (\"0\" + date.getDate()).slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yy') {\n      text += date.getFullYear().toString().slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yyyy') {\n      text += date.getFullYear();\n      parts[part] = true;\n    } else if (!date && (part[0] === 'm' || part[0] === 'd' || part[0] === 'y')) {\n      return false;\n    } else {\n      text += part;\n    }\n\n    return true;\n  });\n  return text;\n};\nvar charCodeZero = '0'.charCodeAt(0);\nvar charCodeNine = '9'.charCodeAt(0);\n\nvar pullDigits = function pullDigits(text, index) {\n  var end = index;\n\n  while (text.charCodeAt(end) >= charCodeZero && text.charCodeAt(end) <= charCodeNine) {\n    end += 1;\n  }\n\n  return text.slice(index, end);\n};\n\nexport var textToValue = function textToValue(text, schema, range, reference, outputFormat) {\n  if (!text) return range ? [] : undefined;\n  var result;\n\n  var addDate = function addDate(parts) {\n    var leapYear = parts.y % 4 === 0 && parts.y % 100 !== 0 || parts.y % 400 === 0; // Do a little sanity checking on the parts first.\n    // If not valid, leave as is.\n\n    if (!parts.m || !parts.d || !parts.y || parts.y.length < 4 || parts.m.length > 2 || parts.d.length > 2 || parts.m > 12 || parts.d > 31 || (parts.m === \"02\" || parts.m === \"2\") && parts.d > (leapYear ? 29 : 28)) return parts; // use time info from reference date\n\n    var time = reference ? [reference.getHours(), reference.getMinutes(), reference.getSeconds(), reference.getMilliseconds()] : null;\n\n    var date = _construct(Date, [parts.y, parts.m - 1, parts.d].concat(time)).toISOString();\n\n    if (date && outputFormat === 'no timezone') {\n      var _handleOffset$toISOSt = handleOffset(date).toISOString().split('T');\n\n      date = _handleOffset$toISOSt[0];\n    }\n\n    if (!range) {\n      if (!result) result = date;\n    } else {\n      if (!result) result = [];\n      result.push(date);\n    } // we've consumed these parts, return an empty object in case we need\n    // to start building up another one for a range\n\n\n    return {};\n  };\n\n  var parts = {};\n  var index = 0;\n  schema.forEach(function (part) {\n    if (index < text.length) {\n      var lower = part.toLowerCase();\n      var _char3 = lower[0];\n      if (parts[_char3] !== undefined) parts = addDate(parts);\n\n      if (_char3 === 'm') {\n        parts.m = pullDigits(text, index);\n        index += parts.m.length;\n      } else if (_char3 === 'd') {\n        var _parts, _parts$d;\n\n        parts.d = pullDigits(text, index); // when format is something like yyyy/mm/dd,\n        // '0' as incomplete day can cause date to be\n        // prematurely calculated.\n        // ex: 2022/01/0 would reutrn 2021/12/31 in addDate()\n\n        if (parts.d === '0') delete parts.d;\n        index += ((_parts = parts) == null ? void 0 : (_parts$d = _parts.d) == null ? void 0 : _parts$d.length) || 0;\n      } else if (_char3 === 'y') {\n        parts.y = pullDigits(text, index);\n        index += parts.y.length;\n\n        if (lower === 'yy' && parts.y.length === 2) {\n          // convert to full year, pivot at 69 based on POSIX strptime()\n          parts.y = \"\" + (parts.y < 69 ? 20 : 19) + parts.y;\n        }\n      } else if (text.slice(index, index + part.length) === part) {\n        index += part.length;\n      } else {\n        // syntax error\n        index = text.length;\n        result = undefined;\n      }\n    }\n  });\n  parts = addDate(parts);\n  if (!result) return range ? [] : undefined;\n  return result;\n};\nexport var valuesAreEqual = function valuesAreEqual(value1, value2) {\n  return Array.isArray(value1) && Array.isArray(value2) && value1.every(function (d1, i) {\n    return d1 === value2[i];\n  }) || value1 === value2;\n};","map":null,"metadata":{},"sourceType":"module"}