{"ast":null,"code":"var _excluded = [\"children\", \"errors\", \"infos\", \"messages\", \"onChange\", \"onReset\", \"onSubmit\", \"onValidate\", \"validate\", \"value\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nimport React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { useAnalytics } from '../../contexts';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { useForwardedRef } from '../../utils';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\nvar defaultValue = {};\nvar defaultTouched = {};\nvar defaultValidationResults = {\n  errors: {},\n  infos: {}\n};\n\nvar stringToArray = function stringToArray(string) {\n  var match = string == null ? void 0 : string.match(/^(.+)\\[([0-9]+)\\]\\.(.*)$/);\n\n  if (match) {\n    var arrayName = match[1],\n        indexOfArray = match[2],\n        arrayObjName = match[3];\n    return {\n      indexOfArray: indexOfArray,\n      arrayName: arrayName,\n      arrayObjName: arrayObjName\n    };\n  }\n\n  return undefined;\n};\n\nvar getFieldValue = function getFieldValue(name, value) {\n  var isArrayField = stringToArray(name);\n\n  if (isArrayField) {\n    var _value$arrayName;\n\n    var indexOfArray = isArrayField.indexOfArray,\n        arrayName = isArrayField.arrayName,\n        arrayObjName = isArrayField.arrayObjName;\n    var obj = (_value$arrayName = value[arrayName]) == null ? void 0 : _value$arrayName[indexOfArray];\n    return arrayObjName ? obj == null ? void 0 : obj[arrayObjName] : obj;\n  }\n\n  return value[name];\n};\n\nvar setFieldValue = function setFieldValue(name, componentValue, prevValue) {\n  var nextValue = _extends({}, prevValue);\n\n  var isArrayField = stringToArray(name);\n\n  if (isArrayField) {\n    var indexOfArray = isArrayField.indexOfArray,\n        arrayName = isArrayField.arrayName,\n        arrayObjName = isArrayField.arrayObjName;\n    if (!nextValue[arrayName]) nextValue[arrayName] = [];\n\n    if (arrayObjName) {\n      var _nextValue$arrayName$;\n\n      if (!nextValue[arrayName][indexOfArray]) nextValue[arrayName][indexOfArray] = (_nextValue$arrayName$ = {}, _nextValue$arrayName$[arrayObjName] = componentValue, _nextValue$arrayName$);\n      nextValue[arrayName][indexOfArray][arrayObjName] = componentValue;\n    } else nextValue[arrayName][indexOfArray] = componentValue;\n  } else {\n    nextValue[name] = componentValue;\n  }\n\n  return nextValue;\n}; // Apply validation rule to field value and send correct messaging.\n\n\nvar validate = function validate(rule, fieldValue, formValue, format, messages) {\n  var result;\n\n  if (typeof rule === 'function') {\n    result = rule(fieldValue, formValue);\n  } else if (rule.regexp) {\n    if (!rule.regexp.test(fieldValue)) {\n      result = rule.message || format({\n        id: 'form.invalid',\n        messages: messages\n      });\n\n      if (rule.status) {\n        result = {\n          message: result,\n          status: rule.status\n        };\n      }\n    }\n  }\n\n  return result;\n}; // Validates particular key in formValue\n\n\nvar validateName = function validateName(validationRules, required) {\n  return function (name, formValue, format, messages) {\n    var fieldValue = getFieldValue(name, formValue);\n    var validationResult;\n\n    if (required && ( // false is for CheckBox\n    fieldValue === undefined || fieldValue === '' || fieldValue === false || Array.isArray(fieldValue) && !fieldValue.length)) {\n      validationResult = format({\n        id: 'form.required',\n        messages: messages\n      });\n    } else if (validationRules) {\n      if (Array.isArray(validationRules)) {\n        validationRules.some(function (rule) {\n          validationResult = validate(rule, fieldValue, formValue, format, messages);\n          return !!validationResult;\n        });\n      } else {\n        validationResult = validate(validationRules, fieldValue, formValue, format, messages);\n      }\n    }\n\n    return validationResult;\n  };\n}; // Validates all keys in formValue\n\n\nvar validateForm = function validateForm(validationRules, formValue, format, messages, omitValid) {\n  var nextErrors = {};\n  var nextInfos = {};\n  validationRules.forEach(function (_ref) {\n    var name = _ref[0],\n        _ref$ = _ref[1],\n        field = _ref$.field,\n        input = _ref$.input;\n\n    if (!omitValid) {\n      nextErrors[name] = undefined;\n      nextInfos[name] = undefined;\n    }\n\n    var result;\n\n    if (input) {\n      // input() a validation function supplied through useFormInput()\n      result = input(name, formValue, format, messages);\n    }\n\n    if (field && !result) {\n      // field() a validation function supplied through useFormField()\n      result = field(name, formValue, format, messages);\n    } // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n\n\n    if (typeof result === 'object') {\n      if (result.status === 'info') {\n        nextInfos[name] = result.message;\n      } else {\n        nextErrors[name] = result.message || result; // could be a node\n      }\n    } else if (typeof result === 'string') {\n      nextErrors[name] = result;\n    }\n  });\n  return [nextErrors, nextInfos];\n};\n\nvar Form = /*#__PURE__*/forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n      _ref2$errors = _ref2.errors,\n      errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors,\n      _ref2$infos = _ref2.infos,\n      infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos,\n      messages = _ref2.messages,\n      onChange = _ref2.onChange,\n      _onReset = _ref2.onReset,\n      _onSubmit = _ref2.onSubmit,\n      onValidate = _ref2.onValidate,\n      _ref2$validate = _ref2.validate,\n      validateOn = _ref2$validate === void 0 ? 'submit' : _ref2$validate,\n      valueProp = _ref2.value,\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n  var formRef = useForwardedRef(ref);\n\n  var _useContext = useContext(MessageContext),\n      format = _useContext.format;\n\n  var _useState = useState(valueProp || defaultValue),\n      valueState = _useState[0],\n      setValueState = _useState[1];\n\n  var value = useMemo(function () {\n    return valueProp || valueState;\n  }, [valueProp, valueState]);\n\n  var _useState2 = useState(defaultTouched),\n      touched = _useState2[0],\n      setTouched = _useState2[1];\n\n  var _useState3 = useState({\n    errors: errorsProp,\n    infos: infosProp\n  }),\n      validationResults = _useState3[0],\n      setValidationResults = _useState3[1]; // maintain a copy of validationResults in a ref for useEffects\n  // which can't depend on validationResults directly without\n  // causing infinite renders.\n\n\n  var validationResultsRef = useRef({}); // Simulated onMount state. Consider Form to be mounted once it has\n  // accounted for values originating from controlled inputs (available\n  // at second rendering).\n\n  var _useState4 = useState('unmounted'),\n      mounted = _useState4[0],\n      setMounted = _useState4[1];\n\n  useEffect(function () {\n    if (!mounted) setMounted('mounting');else if (mounted === 'mounting') setMounted('mounted');\n  }, [mounted]); // `pendingValidation` is the name of the FormField awaiting validation.\n\n  var _useState5 = useState(undefined),\n      pendingValidation = _useState5[0],\n      setPendingValidation = _useState5[1];\n\n  var validationRulesRef = useRef({});\n  var requiredFields = useRef([]);\n  var analyticsRef = useRef({\n    start: new Date(),\n    errors: {}\n  });\n  var sendAnalytics = useAnalytics();\n  var buildValid = useCallback(function (nextErrors) {\n    var valid = false;\n    valid = requiredFields.current.filter(function (n) {\n      return Object.keys(validationRulesRef.current).includes(n);\n    }).every(function (field) {\n      return value[field] && (value[field] !== '' || value[field] !== false);\n    });\n    if (Object.keys(nextErrors).length > 0) valid = false;\n    return valid;\n  }, [value]); // Only keep validation results for current form fields. In the case of a\n  // dynamic form, a field possessing an error may have been removed from the\n  // form; need to clean up any previous related validation results.\n\n  var filterRemovedFields = function filterRemovedFields(prevValidations) {\n    var nextValidations = prevValidations;\n    return Object.keys(nextValidations).filter(function (n) {\n      return !validationRulesRef.current[n] || nextValidations[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextValidations[n];\n    });\n  };\n\n  var updateAnalytics = function updateAnalytics() {\n    var _validationResultsRef;\n\n    var errorFields = Object.keys((_validationResultsRef = validationResultsRef.current) == null ? void 0 : _validationResultsRef.errors);\n    var errorCounts = analyticsRef.current.errors;\n\n    if (errorFields.length > 0) {\n      errorFields.forEach(function (key) {\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n    }\n  };\n\n  var applyValidationRules = useCallback(function (validationRules) {\n    var _validateForm = validateForm(validationRules, value, format, messages),\n        validatedErrors = _validateForm[0],\n        validatedInfos = _validateForm[1];\n\n    setValidationResults(function (prevValidationResults) {\n      // Keep any previous errors and infos for untouched keys,\n      // these may have come from a Submit.\n      var nextErrors = _extends({}, prevValidationResults.errors, validatedErrors);\n\n      var nextInfos = _extends({}, prevValidationResults.infos, validatedInfos); // Remove previous errors and infos for keys no longer in the\n      // form, these may have been fields removed from a dynamic form.\n\n\n      filterRemovedFields(nextErrors);\n      filterRemovedFields(nextInfos);\n      var nextValidationResults = {\n        errors: nextErrors,\n        infos: nextInfos\n      };\n      if (onValidate) onValidate(_extends({}, nextValidationResults, {\n        valid: buildValid(nextErrors)\n      }));\n      validationResultsRef.current = nextValidationResults;\n      updateAnalytics();\n      return nextValidationResults;\n    });\n  }, [buildValid, format, messages, onValidate, value]); // Validate all fields holding values onMount if set to\n  // validate when blur or change.\n\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current); // Use simulated onMount state to account for values provided by\n    // controlled inputs.\n\n    if (mounted !== 'mounted' && ['blur', 'change'].includes(validateOn) && Object.keys(value).length > 0 && Object.keys(touched).length === 0) {\n      applyValidationRules(validationRules.filter(function (_ref3) {\n        var n = _ref3[0];\n        return value[n];\n      }) // Exlude empty arrays which may be initial values in\n      // an input such as DateInput.\n      .filter(function (_ref4) {\n        var n = _ref4[0];\n        return !(Array.isArray(value[n]) && value[n].length === 0);\n      }));\n    }\n  }, [applyValidationRules, mounted, touched, validateOn, value]); // Run validation against fields with pendingValidations from onBlur\n  // and/or onChange.\n\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current);\n    var timer = setTimeout(function () {\n      if (pendingValidation && ['blur', 'change'].includes(validateOn)) {\n        applyValidationRules(validationRules.filter(function (_ref5) {\n          var n = _ref5[0];\n          return touched[n] || pendingValidation.includes(n);\n        }));\n        setPendingValidation(undefined);\n      } // Complete any potential click events before running onBlur validation.\n      // Otherwise, click events like reset, etc. may not be registered. For a\n      // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863\n      // Values empirically tested; 120 was selected because it is the largest\n      // Chrome: 100, Safari: 120, Firefox: 80\n\n    }, 120);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [applyValidationRules, pendingValidation, touched, validateOn]); // Re-run validation rules for all fields with prior errors.\n  // if validate=blur this helps re-validate if there are errors\n  // as the user fixes them (basically act like validate=change for that)\n\n  useEffect(function () {\n    var _validationResultsRef2;\n\n    var validationRules = Object.entries(validationRulesRef.current);\n\n    if ((_validationResultsRef2 = validationResultsRef.current) != null && _validationResultsRef2.errors && Object.keys(validationResultsRef.current.errors).length > 0) {\n      applyValidationRules(validationRules.filter(function (_ref6) {\n        var n = _ref6[0];\n        return touched[n] && validationResultsRef.current.errors[n];\n      }));\n    }\n  }, [applyValidationRules, touched]);\n  useEffect(function () {\n    var element = formRef.current;\n    analyticsRef.current = {\n      start: new Date(),\n      errors: {}\n    };\n    sendAnalytics({\n      type: 'formOpen',\n      element: element\n    });\n    return function () {\n      if (!analyticsRef.current.submitted) {\n        sendAnalytics({\n          type: 'formClose',\n          element: element,\n          errors: analyticsRef.current.errors,\n          elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n        });\n      }\n    };\n  }, [sendAnalytics, formRef]); // There are three basic patterns of handling form input value state:\n  //\n  // 1 - form controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the Form component to supply the values used by the input fields.\n  // In useFormContext(), componentValue would be undefined and formValue\n  // is be set to whatever the form state has. Whenever the form state\n  // changes, we update the contextValue so the input component will use\n  // that. When the input component changes, we will call update() to\n  // update the form state.\n  //\n  // 2 - input controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the input components, like TextInput, to supply the value for it.\n  // In useFormContext(), componentValue is this value and we ensure to\n  // update the form state, via update(), and set the contextValue from\n  // the componentValue. When the input component changes, we will\n  // call update() to update the form state.\n  //\n  // 3 - uncontrolled\n  //\n  // In this model, the caller doesn't set a `value` or `onChange` property\n  // at either the form or input component levels.\n  // In useFormContext(), componentValue is undefined and valueProp is\n  // undefined and nothing much happens here. That is, unless the\n  // calling component needs to know the state in order to work, such\n  // as CheckBox or Select. In this case, those components supply\n  // an initialValue, which will trigger updating the contextValue so\n  // they can have access to it.\n  //\n\n  var formContextValue = useMemo(function () {\n    var useFormInput = function useFormInput(_ref7) {\n      var name = _ref7.name,\n          componentValue = _ref7.value,\n          initialValue = _ref7.initialValue,\n          validateArg = _ref7.validate;\n\n      var _useState6 = useState(initialValue),\n          inputValue = _useState6[0],\n          setInputValue = _useState6[1];\n\n      var formValue = name ? getFieldValue(name, value) : undefined; // for dynamic forms, we need to track when an input has been added to\n      // the form value. if the input is unmounted, we will delete its\n      // key/value from the form value.\n\n      var keyCreated = useRef(false); // This effect is for pattern #2, where the controlled input\n      // component is driving the value via componentValue.\n\n      useEffect(function () {\n        if (name && // we have somewhere to put this\n        componentValue !== undefined && // input driving\n        componentValue !== formValue // don't already have it\n        ) {\n          setValueState(function (prevValue) {\n            return setFieldValue(name, componentValue, prevValue);\n          }); // don't onChange on programmatic changes\n        }\n      }, [componentValue, formValue, name]); // on unmount, if the form is uncontrolled, remove the key/value\n      // from the form value\n\n      useEffect(function () {\n        return function () {\n          if (keyCreated.current) {\n            keyCreated.current = false;\n            setValueState(function (prevValue) {\n              var nextValue = _extends({}, prevValue);\n\n              var isArrayField = stringToArray(name);\n\n              if (isArrayField) {\n                var arrayName = isArrayField.arrayName;\n                delete nextValue[arrayName];\n              } else {\n                delete nextValue[name];\n              }\n\n              return nextValue;\n            });\n          }\n        };\n      }, // eslint-disable-next-line react-hooks/exhaustive-deps\n      [] // only run onmount and unmount\n      ); // Create validation rules for fields\n\n      useEffect(function () {\n        if (validateArg) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n\n          validationRulesRef.current[name].input = validateName(validateArg);\n          return function () {\n            return delete validationRulesRef.current[name].input;\n          };\n        }\n\n        return undefined;\n      }, [validateArg, name]);\n      var useValue;\n      if (componentValue !== undefined) // input component drives, pattern #2\n        useValue = componentValue;else if (valueProp && name && formValue !== undefined) // form drives, pattern #1\n        useValue = formValue;else if (formValue === undefined && name) // form has reset, so reset input value as well\n        useValue = initialValue;else useValue = inputValue;\n      return [useValue, function (nextComponentValue) {\n        if (name) {\n          // we have somewhere to put this\n          var nextTouched = _extends({}, touched);\n\n          nextTouched[name] = true;\n\n          if (!touched[name]) {\n            // don't update if not needed\n            setTouched(nextTouched);\n          } // if nextValue doesn't have a key for name, this must be\n          // uncontrolled form. we will flag this field was added so\n          // we know to remove its value from the form if it is dynamically\n          // removed\n\n\n          if (!(name in value)) keyCreated.current = true;\n          var nextValue = setFieldValue(name, nextComponentValue, value);\n          setValueState(nextValue);\n          if (onChange) onChange(nextValue, {\n            touched: nextTouched\n          });\n        }\n\n        if (initialValue !== undefined) setInputValue(nextComponentValue);\n      }];\n    };\n\n    var useFormField = function useFormField(_ref8) {\n      var errorArg = _ref8.error,\n          infoArg = _ref8.info,\n          name = _ref8.name,\n          required = _ref8.required,\n          disabled = _ref8.disabled,\n          validateArg = _ref8.validate;\n      var error = disabled ? undefined : errorArg || validationResults.errors[name];\n      var info = infoArg || validationResults.infos[name]; // Create validation rules for field\n\n      useEffect(function () {\n        var index = requiredFields.current.indexOf(name);\n\n        if (required) {\n          if (index === -1) requiredFields.current.push(name);\n        } else if (index !== -1) requiredFields.current.splice(index, 1);\n\n        if (validateArg || required) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n\n          validationRulesRef.current[name].field = validateName(validateArg, required);\n          return function () {\n            delete validationRulesRef.current[name].field;\n            var requiredFieldIndex = requiredFields.current.indexOf(name);\n\n            if (requiredFieldIndex !== -1) {\n              requiredFields.current.splice(requiredFieldIndex, 1);\n            }\n          };\n        }\n\n        return undefined;\n      }, [error, name, required, validateArg, disabled]);\n      return {\n        error: error,\n        info: info,\n        inForm: true,\n        onBlur: validateOn === 'blur' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined,\n        onChange: validateOn === 'change' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined\n      };\n    };\n\n    return {\n      useFormField: useFormField,\n      useFormInput: useFormInput\n    };\n  }, [onChange, pendingValidation, touched, validateOn, validationResults.errors, validationResults.infos, value, valueProp]);\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: formRef\n  }, rest, {\n    onReset: function onReset(event) {\n      sendAnalytics({\n        type: 'formReset',\n        element: formRef.current,\n        data: event,\n        errors: analyticsRef.current.errors,\n        elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n      });\n      setPendingValidation(undefined);\n\n      if (!valueProp) {\n        setValueState(defaultValue);\n        if (onChange) onChange(defaultValue, {\n          touched: defaultTouched\n        });\n      }\n\n      setTouched(defaultTouched);\n      setValidationResults(defaultValidationResults);\n      analyticsRef.current = {\n        start: new Date(),\n        errors: {}\n      };\n\n      if (_onReset) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = defaultValue;\n\n        _onReset(adjustedEvent);\n      }\n    },\n    onSubmit: function onSubmit(event) {\n      // Don't submit the form via browser form action. We don't want it\n      // if the validation fails. And, we assume a javascript action handler\n      // otherwise.\n      event.preventDefault();\n      setPendingValidation(undefined);\n\n      var _validateForm2 = validateForm(Object.entries(validationRulesRef.current), value, format, messages, true),\n          nextErrors = _validateForm2[0],\n          nextInfos = _validateForm2[1];\n\n      setValidationResults(function () {\n        var nextValidationResults = {\n          errors: nextErrors,\n          infos: nextInfos,\n          // Show form's validity when clicking on Submit\n          valid: buildValid(nextErrors)\n        };\n        if (onValidate) onValidate(nextValidationResults);\n        validationResultsRef.current = nextValidationResults;\n        updateAnalytics();\n        return nextValidationResults;\n      });\n\n      if (Object.keys(nextErrors).length === 0 && _onSubmit) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = value;\n        adjustedEvent.touched = touched;\n\n        _onSubmit(adjustedEvent);\n\n        sendAnalytics({\n          type: 'formSubmit',\n          element: formRef.current,\n          data: adjustedEvent,\n          errors: analyticsRef.current.errors,\n          elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n        });\n        analyticsRef.current.errors = {};\n        analyticsRef.current.submitted = true;\n      }\n    }\n  }), /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: formContextValue\n  }, children));\n});\nForm.displayName = 'Form';\nForm.propTypes = FormPropTypes;\nexport { Form };","map":null,"metadata":{},"sourceType":"module"}