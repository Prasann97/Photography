{"ast":null,"code":"// This file contains helper functions for DataTable, to keep the component\n// files simpler.\nexport var set = function set(obj, path, value) {\n  var parts = path;\n  if (Object(obj) !== obj) return obj;\n  if (!Array.isArray(path)) parts = path.toString().match(/[^.[\\]]+/g) || [];\n  parts.slice(0, -1).reduce(function (acc, item, index) {\n    if (Object(acc[item]) === acc[item]) {\n      return acc[item];\n    }\n\n    acc[item] = Math.abs(parts[index + 1]) > 0 === +parts[index + 1] ? [] : {};\n    return acc[item];\n  }, obj)[parts[parts.length - 1]] = value;\n  return obj;\n}; // get the value for the property in the datum object\n\nexport var datumValue = function datumValue(datum, property) {\n  if (!property) return undefined;\n  var parts = property.split('.');\n\n  if (parts.length === 1) {\n    return datum[property];\n  }\n\n  if (!datum[parts[0]]) {\n    return undefined;\n  }\n\n  return datumValue(datum[parts[0]], parts.slice(1).join('.'));\n}; // get the primary property name\n\nexport var normalizePrimaryProperty = function normalizePrimaryProperty(columns, primaryKey) {\n  var result;\n  columns.forEach(function (column) {\n    // remember the first key property\n    if (column.primary && !result) {\n      result = column.property;\n    }\n  });\n\n  if (!result) {\n    if (primaryKey === false) result = undefined;else if (primaryKey) result = primaryKey;else if (columns.length > 0) result = columns[0].property;\n  }\n\n  return result;\n}; // initialize filters with empty strings\n\nexport var initializeFilters = function initializeFilters(columns) {\n  var result = {};\n  columns.forEach(function (column) {\n    if (column.search) {\n      result[column.property] = '';\n    }\n  });\n  return result;\n}; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n\nvar escapeRegExp = function escapeRegExp(input) {\n  return input.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}; // filter data based on filters then sort\n\n\nexport var filterAndSortData = function filterAndSortData(data, filters, onSearch, sort) {\n  var result = data;\n\n  if (!onSearch) {\n    var regexps = {};\n    Object.keys(filters).filter(function (n) {\n      return filters[n];\n    }).forEach(function (n) {\n      regexps[n] = new RegExp(escapeRegExp(filters[n]), 'i');\n    });\n\n    if (Object.keys(regexps).length > 0) {\n      result = data.filter(function (datum) {\n        return !Object.keys(regexps).some(function (property) {\n          return !regexps[property].test(datumValue(datum, property));\n        });\n      });\n    }\n  }\n\n  if (sort && !sort.external) {\n    var property = sort.property,\n        direction = sort.direction;\n    result = result === data ? [].concat(data) : result; // don't sort caller's data\n\n    var sortAsc = direction === 'asc';\n    var before = sortAsc ? 1 : -1;\n    var after = sortAsc ? -1 : 1;\n    result.sort(function (d1, d2) {\n      var d1Val = datumValue(d1, property);\n      var d2Val = datumValue(d2, property);\n\n      if (typeof d1Val === 'string' && typeof d2Val === 'string' || typeof d1Val === 'string' && !d2Val || typeof d2Val === 'string' && !d1Val) {\n        var sortResult = (d1Val || '').localeCompare(d2Val || '', undefined, {\n          sensitivity: 'base'\n        });\n        return sortAsc ? sortResult : -sortResult;\n      }\n\n      if (d1Val > d2Val) return before;\n      if (d1Val < d2Val) return after;\n      return 0;\n    });\n  }\n\n  return result;\n}; // aggregate reducers\n\nvar sumReducer = function sumReducer(accumulated, next) {\n  return accumulated + next;\n};\n\nvar minReducer = function minReducer(accumulated, next) {\n  return accumulated === undefined ? next : Math.min(accumulated, next);\n};\n\nvar maxReducer = function maxReducer(accumulated, next) {\n  return accumulated === undefined ? next : Math.max(accumulated, next);\n};\n\nvar reducers = {\n  max: maxReducer,\n  min: minReducer,\n  sum: sumReducer\n}; // aggregate reducers init values\n\nvar reducersInitValues = {\n  min: Number.MAX_VALUE,\n  max: Number.MIN_VALUE,\n  sum: 0\n}; // aggregate a single column\n\nvar aggregateColumn = function aggregateColumn(column, data) {\n  var value;\n\n  if (column.aggregate === 'avg') {\n    value = data.map(function (d) {\n      return datumValue(d, column.property);\n    }).reduce(sumReducer);\n    value /= data.length;\n  } else {\n    value = data.map(function (d) {\n      return datumValue(d, column.property);\n    }).reduce(reducers[column.aggregate], reducersInitValues[column.aggregate]);\n  }\n\n  return value;\n}; // aggregate all columns that can\n\n\nvar aggregate = function aggregate(columns, data) {\n  var result = {};\n  columns.forEach(function (column) {\n    if (column.aggregate) {\n      var value = aggregateColumn(column, data);\n      result = set(result, column.property, value);\n    }\n  });\n  return result;\n}; // build the values for the footer cells\n\n\nexport var buildFooterValues = function buildFooterValues(columns, data) {\n  var aggregateValues = aggregate(columns, data);\n  var result = {};\n  columns.forEach(function (column) {\n    if (column.footer) {\n      if (column.footer.aggregate) {\n        var value = datumValue(aggregateValues, column.property);\n        result = set(result, column.property, value);\n      } else {\n        result = set(result, column.property, column.footer);\n      }\n    }\n  });\n  return result;\n}; // looks at the groupBy property of each data object and returns an\n// array with one item for each unique value of that property.\n\nexport var buildGroups = function buildGroups(columns, data, groupBy, primaryProperty) {\n  var result;\n\n  if (groupBy != null && groupBy.property || typeof groupBy === 'string') {\n    result = [];\n    var groupMap = {};\n    data.forEach(function (datum) {\n      var _groupBy$expandable;\n\n      var key = datumValue(datum, primaryProperty);\n      var isGroup = key && ((_groupBy$expandable = groupBy.expandable) == null ? void 0 : _groupBy$expandable.includes(key));\n      var groupByProperty = groupBy.property ? groupBy.property : groupBy;\n      var groupValue = isGroup ? key : datumValue(datum, groupByProperty);\n\n      if (!groupMap[groupValue]) {\n        var group = {\n          data: [],\n          datum: isGroup ? datum : {},\n          key: groupValue\n        };\n        group.datum[groupByProperty] = groupValue;\n        result.push(group);\n        groupMap[groupValue] = group;\n      }\n\n      if (!isGroup) groupMap[groupValue].data.push(datum);\n    }); // include any aggregate column values across the data for each group\n    // If expandable was specified we let the onUpdate callback do it since\n    // we may not have access to all the data to aggregate it.\n\n    if (!groupBy.expandable) {\n      columns.forEach(function (column) {\n        if (column.aggregate) {\n          result.forEach(function (group) {\n            var datum = group.datum;\n            datum[column.property] = aggregateColumn(column, group.data);\n          });\n        }\n      });\n    }\n  } else if (groupBy != null && groupBy.expandable) {\n    result = groupBy.expandable.map(function (key) {\n      return {\n        data: [],\n        datum: {},\n        key: key\n      };\n    });\n  }\n\n  return result;\n}; // build group expanded state, expanding any in groupBy.expand\n\nexport var buildGroupState = function buildGroupState(groups, groupBy) {\n  var result = {};\n\n  if (groups) {\n    groups.forEach(function (_ref) {\n      var key = _ref.key;\n      if (key) result[key] = {\n        expanded: false\n      };\n    });\n  }\n\n  if (groupBy && groupBy.expand) {\n    groupBy.expand.forEach(function (value) {\n      result[value] = {\n        expanded: true\n      };\n    });\n  }\n\n  return result;\n};\nexport var normalizeBackgroundColor = function normalizeBackgroundColor(theme) {\n  var background = theme.background; // context background\n\n  if (typeof background === 'string') return background;\n  if (background.light && background.dark) return background;\n  if (background.color) return background.color;\n  return undefined;\n};\nexport var normalizeRowProp = function normalizeRowProp(name, rowProp, prop) {\n  if (rowProp && rowProp[name]) return rowProp[name];\n  return prop;\n};\nvar tableContextNames = ['header', 'body', 'footer'];\nvar cellPropertyNames = ['background', 'border', 'pad']; // Convert property specific cell props to context specific cell props.\n// For example, background={{ header: { background } }}\n// will become cellProps.header.background\n\nexport var normalizeCellProps = function normalizeCellProps(props, theme) {\n  var result = {};\n  tableContextNames.forEach(function (context) {\n    result[context] = {\n      pinned: {}\n    };\n    cellPropertyNames.forEach(function (propName) {\n      var _props$propName, _theme$dataTable, _theme$dataTable$cont, _theme$table, _theme$table$context, _props$propName3, _props$propName3$pinn, _props$propName5, _theme$dataTable2, _theme$dataTable2$pin, _theme$dataTable2$pin2;\n\n      var value = (props == null ? void 0 : (_props$propName = props[propName]) == null ? void 0 : _props$propName[context]) || // if the propName is used without context, it applies to all contexts\n      tableContextNames.every(function (n) {\n        var _props$propName2;\n\n        return !(props != null && (_props$propName2 = props[propName]) != null && _props$propName2[n]);\n      }) && (props == null ? void 0 : props[propName]) || (theme == null ? void 0 : (_theme$dataTable = theme.dataTable) == null ? void 0 : (_theme$dataTable$cont = _theme$dataTable[context]) == null ? void 0 : _theme$dataTable$cont[propName]) || (theme == null ? void 0 : (_theme$table = theme.table) == null ? void 0 : (_theme$table$context = _theme$table[context]) == null ? void 0 : _theme$table$context[propName]);\n      if (value !== undefined) result[context][propName] = value; // pinned case\n\n      value = (props == null ? void 0 : (_props$propName3 = props[propName]) == null ? void 0 : (_props$propName3$pinn = _props$propName3.pinned) == null ? void 0 : _props$propName3$pinn[context]) || context === 'body' && tableContextNames.every(function (n) {\n        var _props$propName4, _props$propName4$pinn;\n\n        return !(props != null && (_props$propName4 = props[propName]) != null && (_props$propName4$pinn = _props$propName4.pinned) != null && _props$propName4$pinn[n]);\n      }) && (props == null ? void 0 : (_props$propName5 = props[propName]) == null ? void 0 : _props$propName5.pinned) || (theme == null ? void 0 : (_theme$dataTable2 = theme.dataTable) == null ? void 0 : (_theme$dataTable2$pin = _theme$dataTable2.pinned) == null ? void 0 : (_theme$dataTable2$pin2 = _theme$dataTable2$pin[context]) == null ? void 0 : _theme$dataTable2$pin2[propName]);\n\n      if (value !== undefined) {\n        if (propName === 'background' && theme.background && value.opacity && !value.color) // theme context has an active background color but the\n          // theme doesn't set an explicit color, repeat the context\n          // background explicitly\n          value.color = normalizeBackgroundColor(theme);\n        if (context === 'body') // in case we have pinned columns, store the pinned stuff in\n          // cellProps.body.pinned\n          result[context].pinned[propName] = value;else if (props.pin === true || props.pin === context) // this context is pinned, use the pinned value directly\n          result[context][propName] = value;\n      }\n    });\n  });\n  return result;\n};\nexport var normalizeRowCellProps = function normalizeRowCellProps(rowProps, cellProps, primaryKey, index) {\n  var result = {\n    pinned: {}\n  };\n  ['background', 'border', 'pad'].forEach(function (propName) {\n    var _rowProps$primaryKey;\n\n    var row = primaryKey && rowProps && (rowProps == null ? void 0 : (_rowProps$primaryKey = rowProps[primaryKey]) == null ? void 0 : _rowProps$primaryKey[propName]);\n    var cell = cellProps[propName];\n    var value = row && (Array.isArray(row) ? row[index % row.length] : row) || (Array.isArray(cell) ? cell[index % cell.length] : cell);\n    if (value !== undefined) result[propName] = value;\n    var rowPin = rowProps && rowProps.pinned && rowProps.pinned[propName];\n    var cellPin = cellProps.pinned[propName];\n    value = rowPin && (Array.isArray(rowPin) ? rowPin[index % rowPin.length] : rowPin) || (Array.isArray(cellPin) ? cellPin[index % cellPin.length] : cellPin);\n    if (value !== undefined) result.pinned[propName] = value;\n  });\n  return result;\n};","map":null,"metadata":{},"sourceType":"module"}