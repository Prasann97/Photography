{"ast":null,"code":"var _excluded = [\"a11yTitle\", \"axis\", \"bounds\", \"chart\", \"data\", \"detail\", \"gap\", \"guide\", \"legend\", \"offset\", \"placeholder\", \"pad\", \"series\", \"size\"],\n    _excluded2 = [\"property\", \"type\", \"x\", \"y\"],\n    _excluded3 = [\"property\"];\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport React, { forwardRef, useContext, useMemo, useState } from 'react';\nimport { ThemeContext } from 'styled-components';\nimport { Box } from '../Box';\nimport { Chart, calcs, calcBounds } from '../Chart';\nimport { Grid } from '../Grid';\nimport { Stack } from '../Stack';\nimport { Text } from '../Text';\nimport { parseMetricToNum } from '../../utils';\nimport { Detail } from './Detail';\nimport { Legend } from './Legend';\nimport { XAxis } from './XAxis';\nimport { YAxis } from './YAxis';\nimport { XGuide } from './XGuide';\nimport { YGuide } from './YGuide';\nimport { createDateFormat, halfPad, heightYGranularity, largestSize, points } from './utils';\nimport { DataChartPropTypes } from './propTypes';\nvar stackedChartType = {\n  areas: 'area',\n  bars: 'bar',\n  lines: 'line'\n}; // DataChart takes a generic data array of objects plus as few properties\n// as possible, and creates a Stack of Charts with x and y axes, a legend,\n// and interactive detail.\n// Much of the code here-in involves the \"few properties\" aspect where we\n// normalize and automatically handle whatever the caller didn't specify.\n\nvar DataChart = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var _boundsProp$y;\n\n  var a11yTitle = _ref.a11yTitle,\n      _ref$axis = _ref.axis,\n      axisProp = _ref$axis === void 0 ? true : _ref$axis,\n      _ref$bounds = _ref.bounds,\n      boundsProp = _ref$bounds === void 0 ? 'align' : _ref$bounds,\n      chart = _ref.chart,\n      _ref$data = _ref.data,\n      data = _ref$data === void 0 ? [] : _ref$data,\n      detail = _ref.detail,\n      _ref$gap = _ref.gap,\n      gap = _ref$gap === void 0 ? 'small' : _ref$gap,\n      guideProp = _ref.guide,\n      legend = _ref.legend,\n      offset = _ref.offset,\n      placeholder = _ref.placeholder,\n      padProp = _ref.pad,\n      seriesProp = _ref.series,\n      size = _ref.size,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  var theme = useContext(ThemeContext) || defaultProps.theme; // legend interaction, if any\n\n  var _useState = useState(),\n      activeProperty = _useState[0],\n      setActiveProperty = _useState[1]; // normalize seriesProp to an array of objects, one per property\n\n\n  var series = useMemo(function () {\n    if (Array.isArray(seriesProp)) return seriesProp.filter(function (s) {\n      return s.property || typeof s === 'string';\n    }).map(function (s) {\n      return typeof s === 'string' ? {\n        property: s\n      } : s;\n    });\n    if (typeof seriesProp === 'string') return [{\n      property: seriesProp\n    }];\n    if (seriesProp) return [seriesProp];\n    return [];\n  }, [seriesProp]);\n\n  var getPropertySeries = function getPropertySeries(prop) {\n    return series.find(function (_ref2) {\n      var property = _ref2.property;\n      return prop === property;\n    });\n  }; // Normalize chart to an array of objects.\n  // Each chart has one or more properties associated with it.\n  // A stacked bar or area chart has an array of properties.\n  // A point chart can have x, y, thickness, and color each driven\n  // by a separate property.\n\n\n  var charts = useMemo(function () {\n    if (!chart) {\n      if (series.length === 1) return series.filter(function (s) {\n        return s.property;\n      }).map(function (s) {\n        return {\n          property: s.property\n        };\n      }); // if we have more than one property, we'll use the first for\n      // the x-axis and we'll plot the rest\n\n      return series.slice(1).map(function (s) {\n        return {\n          property: s.property\n        };\n      });\n    }\n\n    if (Array.isArray(chart)) return chart.map(function (c) {\n      return typeof c === 'string' ? {\n        property: c\n      } : c;\n    }).filter(function (_ref3) {\n      var property = _ref3.property;\n      return property;\n    });\n    if (typeof chart === 'string') return [{\n      property: chart\n    }];\n    if (chart) return [chart];\n    return [];\n  }, [chart, series]); // map the series property values into their own arrays\n\n  var seriesValues = useMemo(function () {\n    var result = {};\n    series.forEach(function (_ref4) {\n      var property = _ref4.property;\n      result[property] = data.map(function (d) {\n        return d[property];\n      });\n    });\n    return result;\n  }, [data, series]); // Setup the values property for each chart.\n  // The index into 'charts' can be used to index into 'chartValues'.\n\n  var chartValues = useMemo(function () {\n    return charts.map(function (_ref5) {\n      var opacity = _ref5.opacity,\n          property = _ref5.property,\n          type = _ref5.type;\n\n      if (property) {\n        if (Array.isArray(property)) {\n          // A range chart or a stacked bar or area chart has multiple\n          // properties.\n          // In this case, this returns an array of values,\n          // one per property.\n          if (stackedChartType[type]) {\n            // Further down, where we render, each property is rendered\n            // using a separate Chart component and the values are stacked\n            // such that they line up appropriately.\n            var totals = [];\n            return property.map(function (cp) {\n              // handle object or string\n              var aProperty = cp.property || cp;\n              var values = seriesValues[aProperty];\n              if (!values) return undefined; // property name isn't valid\n\n              return values.map(function (v, i) {\n                var base = totals[i] || 0;\n                totals[i] = base + v;\n                if (type === 'lines') return [i, base + v];\n                return [i, base, base + v];\n              });\n            });\n          }\n\n          return data.map(function (_, index) {\n            return [index].concat(property.map(function (p) {\n              return seriesValues[p] ? seriesValues[p][index] : data[index][p];\n            }));\n          });\n        }\n\n        if (typeof property === 'object') {\n          // When 'property' is an array, the keys of this array indicate\n          // which property drives which part of the rendered Chart.\n          var color = property.color,\n              thickness = property.thickness,\n              x = property.x,\n              y = property.y,\n              y2 = property.y2;\n          return seriesValues[x].map(function (value, index) {\n            var aValue = {\n              value: [value]\n            };\n            aValue.value.push(seriesValues[y][index]);\n            if (y2) aValue.value.push(seriesValues[y2][index]);\n\n            if (thickness) {\n              var t = seriesValues[thickness.property || thickness][index];\n              aValue.thickness = thickness.transform ? thickness.transform(t) : t;\n            }\n\n            if (color) {\n              var c = seriesValues[color.property || color][index];\n              aValue.color = color.transform ? color.transform(c) : c;\n            }\n\n            if (opacity) aValue.opacity = opacity;\n            return aValue;\n          });\n        }\n\n        return seriesValues[property];\n      }\n\n      return undefined;\n    });\n  }, [charts, data, seriesValues]); // map granularities to work well with the number of data points we have\n\n  var granularities = useMemo(function () {\n    var medium; // determine a good medium granularity that will align well with the\n    // length of the data\n\n    var steps = data.length - 1; // special case property driven point charts\n\n    if (charts[0] && typeof charts[0].property === 'object') medium = 3;else if (steps < 4) medium = data.length;else if (steps === 4) medium = 3;else if (steps % 4 === 0) medium = 5;else if (steps % 3 === 0) medium = 4;else if (steps % 2 === 0) medium = 3;else medium = 2;\n    return {\n      x: {\n        coarse: Math.min(data.length, 2),\n        fine: data.length,\n        medium: medium\n      },\n      y: _extends({}, heightYGranularity[size && size.height || 'small'] || {\n        fine: 5,\n        medium: 3\n      }, {\n        coarse: 2\n      })\n    };\n  }, [charts, data.length, size]); // normalize axis to objects, convert granularity to a number\n\n  var axis = useMemo(function () {\n    if (!axisProp) return undefined;\n    var result = {};\n    if (axisProp === true || axisProp.x === true) result.x = {};\n    if (axisProp === true || axisProp.y === true) result.y = {};\n    if (!result.x && axisProp.x) result.x = typeof axisProp.x === 'string' ? {\n      property: axisProp.x\n    } : _extends({}, axisProp.x);\n    if (!result.y && axisProp.y) result.y = typeof axisProp.y === 'string' ? {\n      property: axisProp.y\n    } : _extends({}, axisProp.y);\n\n    if (result.x) {\n      if (!result.x.property) {\n        // see if we have a point chart that has an x property\n        if (data && data[0]) {\n          if (data[0].date) result.x.property = 'date';else if (data[0].time) result.x.property = 'time';\n        }\n      }\n\n      if (!result.x.granularity) result.x.granularity = 'coarse';\n    }\n\n    if (result.y) {\n      if (!result.y.property && charts[0]) // see if we have a point chart that has an x property\n        result.y.property = charts[0].property.y || charts[0].property;\n      if (!result.y.granularity) result.y.granularity = 'coarse';\n    } // calculate number of entries based on granularity\n\n\n    if (result.x) {\n      var _result$x$granularity = result.x.granularity,\n          granularity = _result$x$granularity === void 0 ? 'coarse' : _result$x$granularity;\n      result.x.count = granularities.x[granularity];\n    }\n\n    if (result.y) {\n      var _result$y$granularity = result.y.granularity,\n          _granularity = _result$y$granularity === void 0 ? 'coarse' : _result$y$granularity;\n\n      result.y.count = granularities.y[_granularity];\n    }\n\n    return result;\n  }, [axisProp, data, charts, granularities]); // calculate axis, bounds, and thickness for each chart\n\n  var chartProps = useMemo(function () {\n    var steps = [];\n    var coarseness = [undefined, 5];\n\n    if (axis && axis.x) {\n      var _axis$x$granularity = axis.x.granularity,\n          granularity = _axis$x$granularity === void 0 ? 'coarse' : _axis$x$granularity;\n      steps[0] = granularities.x[granularity] - 1;\n    } else steps[0] = data.length - 1;\n\n    if (axis && axis.y) {\n      var _axis$y$granularity = axis.y.granularity,\n          _granularity2 = _axis$y$granularity === void 0 ? 'coarse' : _axis$y$granularity;\n\n      steps[1] = granularities.y[_granularity2] - 1;\n    } else steps[1] = 1;\n\n    var chartBounds = chartValues.map(function (_, index) {\n      var type = charts[index].type;\n\n      if (stackedChartType[type]) {\n        var _chartValues$index, _chartValues$index$; // merge values for bars, areas, and lines cases\n\n\n        var mergedValues = ((_chartValues$index = chartValues[index]) == null ? void 0 : (_chartValues$index$ = _chartValues$index[0]) == null ? void 0 : _chartValues$index$.slice(0)) || [];\n        chartValues[index].slice(1) // skip first index as that is the x value\n        .filter(function (values) {\n          return values;\n        }) // property name isn't valid\n        .forEach(function (values) {\n          mergedValues = mergedValues.map(function (__, i) {\n            return type === 'lines' ? [i, Math.min(mergedValues[i][1], values[i][1]), Math.max(mergedValues[i][1], values[i][1])] : [i, Math.min(mergedValues[i][1], values[i][1]), Math.max(mergedValues[i][2], values[i][2])];\n          });\n        });\n        return calcBounds(mergedValues, {\n          coarseness: coarseness,\n          steps: steps\n        });\n      } // if this is a data driven x chart, set coarseness for x\n\n\n      return calcBounds(chartValues[index], {\n        coarseness: charts[index].property.x ? [5, 5] : coarseness,\n        steps: steps\n      });\n    });\n\n    if (boundsProp === 'align' && chartBounds.length) {\n      var alignedBounds = [].concat(chartBounds[0]);\n      chartBounds.forEach(function (bounds) {\n        alignedBounds[0][0] = Math.min(alignedBounds[0][0], bounds[0][0]);\n        alignedBounds[0][1] = Math.max(alignedBounds[0][1], bounds[0][1]);\n        alignedBounds[1][0] = Math.min(alignedBounds[1][0], bounds[1][0]);\n        alignedBounds[1][1] = Math.max(alignedBounds[1][1], bounds[1][1]);\n      });\n      chartBounds = chartBounds.map(function () {\n        return alignedBounds;\n      });\n    }\n\n    if (typeof boundsProp === 'object') {\n      if (boundsProp.y) chartBounds = chartBounds.map(function (b) {\n        return [b[0], [].concat(boundsProp.y)];\n      });\n    }\n\n    return chartValues.map(function (values, index) {\n      var _charts$index = charts[index],\n          thickness = _charts$index.thickness,\n          type = _charts$index.type;\n      var calcValues = stackedChartType[type] ? values[0] : values;\n      return calcs(calcValues, {\n        bounds: chartBounds[index],\n        steps: steps,\n        thickness: thickness\n      });\n    });\n  }, [axis, boundsProp, charts, chartValues, data, granularities]); // normalize how we style data properties for use by Legend and Detail\n\n  var seriesStyles = useMemo(function () {\n    var result = {}; // start from what we were explicitly given\n\n    charts.forEach(function (_ref6, index) {\n      var color = _ref6.color,\n          dash = _ref6.dash,\n          point = _ref6.point,\n          property = _ref6.property,\n          round = _ref6.round,\n          thickness = _ref6.thickness,\n          type = _ref6.type;\n      var calcThickness = chartProps[index].thickness;\n\n      if (typeof property === 'object' && !Array.isArray(property)) {\n        // data driven point chart\n        Object.keys(property).forEach(function (aspect) {\n          var prop = property[aspect];\n          if (!result[prop.property || prop]) result[prop.property || prop] = {\n            aspect: aspect\n          };\n        });\n      } else {\n        var props = Array.isArray(property) ? property : [property];\n        props.forEach(function (prop) {\n          var p = prop.property || prop;\n          var pColor = prop.color || color;\n          if (!result[p]) result[p] = {};\n          if (pColor && !result[p].color) result[p].color = pColor;\n          if (point && !result[p].point) result[p].point = point;else if (type === 'point') result[p].point = false;\n          if ((thickness || calcThickness) && !result[p].thickness) result[p].thickness = thickness || calcThickness;\n          if (round !== undefined && result[p].round === undefined) result[p].round = round;\n          if (dash !== undefined && result[p].dash === undefined) result[p].dash = dash;\n          if (result[p].type === undefined) result[p].type = type;\n        });\n      }\n    }); // set color for any non-aspect properties we don't have one for yet\n\n    var colorIndex = 0;\n    var pointIndex = 0;\n    Object.keys(result).forEach(function (key) {\n      var seriesStyle = result[key];\n\n      if (!seriesStyle.aspect && !seriesStyle.color) {\n        seriesStyle.color = \"graph-\" + colorIndex;\n        colorIndex += 1;\n      } // set opacity if it isn't set and this isn't the active property\n\n\n      if (activeProperty !== undefined && activeProperty !== key) {\n        seriesStyle.opacity = 'medium';\n      }\n\n      if (seriesStyle.point === false) {\n        seriesStyle.point = points[pointIndex];\n        pointIndex += 1;\n      }\n    });\n    return result;\n  }, [activeProperty, charts, chartProps]); // normalize guide\n\n  var guide = useMemo(function () {\n    if (!guideProp) return undefined;\n    var result;\n\n    if (guideProp === true) {\n      result = {\n        x: {},\n        y: {}\n      };\n    } else {\n      result = {};\n      if (guideProp.x) result.x = _extends({}, guideProp.x);\n      if (guideProp.y) result.y = _extends({}, guideProp.y);\n    } // set counts\n\n\n    if (result.x) {\n      // if no granularity and axis, align count with axis\n      if (!result.x.granularity && axis && axis.x) result.x.count = axis.x.count;\n      if (!result.x.count) result.x.count = granularities.x[result.x.granularity || 'coarse'];\n    }\n\n    if (result.y) {\n      // if no granularity and axis, align count with axis\n      if (!result.y.granularity && axis && axis.y) result.y.count = axis.y.count;\n      if (!result.y.count) result.y.count = granularities.y[result.y.granularity || 'coarse'];\n    }\n\n    return result;\n  }, [axis, granularities, guideProp]); // set the pad to half the thickness, based on the chart types\n  // except when using offset, then add even more horizontal pad\n\n  var pad = useMemo(function () {\n    if (padProp !== undefined) return padProp;\n    var result = {};\n    charts.forEach(function (_ref7, index) {\n      var type = _ref7.type;\n      var thickness = chartProps[index].thickness;\n      result.horizontal = largestSize(result.horizontal, halfPad[thickness]);\n      if (type && type !== 'bar') result.vertical = largestSize(result.vertical, halfPad[thickness]);\n    });\n    return result;\n  }, [chartProps, charts, padProp]); // calculate the thickness in pixels of each chart\n\n  var thicknesses = useMemo(function () {\n    return offset ? charts.map(function (_, index) {\n      var thickness = chartProps[index].thickness;\n      return parseMetricToNum(theme.global.edgeSize[thickness] || thickness);\n    }) : undefined;\n  }, [charts, chartProps, offset, theme]); // normalize any offset gap\n\n  var offsetGap = useMemo(function () {\n    return (offset == null ? void 0 : offset.gap) && parseMetricToNum(theme.global.edgeSize[offset.gap] || offset.gap) || 0;\n  }, [offset, theme]); // calculate the offset for each chart, which is a sum of the thicknesses\n  // any offset gaps that preceded it\n\n  var offsets = useMemo(function () {\n    if (offset) {\n      return thicknesses.map(function (t, i) {\n        return thicknesses.slice(0, i).reduce(function (a, b) {\n          return a + b + offsetGap;\n        }, 0);\n      });\n    }\n\n    return undefined;\n  }, [offset, offsetGap, thicknesses]); // Calculate the total pad we should add to the end of each chart.\n  // We do this to shrink the width of each chart so we can shift them\n  // via `translate` and have them take up the right amount of width.\n\n  var offsetPad = useMemo(function () {\n    return offsets ? offsets[offsets.length - 1] + thicknesses[thicknesses.length - 1] + \"px\" : undefined;\n  }, [offsets, thicknesses]); // The thickness of the segments. We need to convert to numbers\n  // to be able to compare across charts where some might be using T-shirt\n  // labels and others might be pixel values.\n\n  var segmentThickness = useMemo(function () {\n    var result = 0;\n    charts.forEach(function (_, index) {\n      var thickness = chartProps[index].thickness;\n      result = Math.max(result, parseMetricToNum(theme.global.edgeSize[thickness] || thickness));\n    });\n    return result + \"px\";\n  }, [charts, chartProps, theme]);\n  var dateFormats = useMemo(function () {\n    var result = {};\n    var full = axis && axis.x && axis.x.granularity === 'coarse';\n    series.forEach(function (_ref8) {\n      var property = _ref8.property,\n          render = _ref8.render;\n\n      if (!render && data.length > 1 && typeof data[0][property] === 'string') {\n        result[property] = createDateFormat(data[0][property], data[data.length - 1][property], full);\n      }\n    });\n    return result;\n  }, [axis, data, series]);\n\n  var renderValue = function renderValue(serie, dataIndex, valueArg) {\n    var value;\n\n    if (valueArg !== undefined) {\n      if (serie && serie.render) return serie.render(valueArg);\n      value = valueArg;\n    } else {\n      var datum = data[dataIndex];\n      value = datum[serie.property];\n      if (serie && serie.render) return serie.render(value, datum, serie.property);\n    }\n\n    if (serie) {\n      var dateFormat = dateFormats[serie.property];\n      if (dateFormat) return dateFormat(new Date(value));\n      if (serie.prefix) value = \"\" + serie.prefix + value;\n      if (serie.suffix) value = \"\" + value + serie.suffix;\n    }\n\n    return value;\n  }; // TODO: revisit how x/y axis are hooked up to charts and series\n\n\n  var xAxisElement = axis && axis.x && chartProps.length ? /*#__PURE__*/React.createElement(XAxis, {\n    axis: axis,\n    values: (Array.isArray(chartProps[0]) ? chartProps[0][0] : chartProps[0]).axis[0],\n    pad: offsetPad ? _extends({}, pad, {\n      end: offsetPad\n    }) : pad,\n    renderValue: renderValue,\n    thickness: segmentThickness,\n    serie: axis.x.property && getPropertySeries(axis.x.property),\n    style: offsetPad ? {\n      transform: \"translate(\" + offsets[Math.floor(offsets.length / 2)] + \"px, 0px)\"\n    } : {},\n    theme: theme\n  }) : null;\n  var yAxisElement = axis && axis.y && (chartProps.length || boundsProp != null && boundsProp.y) ? /*#__PURE__*/React.createElement(YAxis, {\n    axis: axis,\n    values: (boundsProp == null ? void 0 : (_boundsProp$y = boundsProp.y) == null ? void 0 : _boundsProp$y.slice(0).reverse()) || (Array.isArray(chartProps[0]) ? chartProps[0][0] : chartProps[0]).axis[1],\n    pad: pad,\n    renderValue: renderValue,\n    serie: axis.y.property && getPropertySeries(axis.y.property)\n  }) : null;\n  var stackFill = useMemo(function () {\n    if (size === 'fill' || size && size.width === 'fill' && size.height === 'fill') return true;\n    if (size && size.width === 'fill') return 'horizontal';\n    if (size && size.height === 'fill') return 'vertical';\n    return undefined;\n  }, [size]);\n  var guidingChild = useMemo(function () {\n    var result = 0;\n    if (guide && guide.x) result += 1;\n    if (guide && guide.y) result += 1;\n    return result;\n  }, [guide]);\n  var stackElement = /*#__PURE__*/React.createElement(Stack, {\n    gridArea: \"charts\",\n    guidingChild: guidingChild,\n    fill: stackFill\n  }, guide && guide.x && /*#__PURE__*/React.createElement(XGuide, {\n    guide: guide,\n    pad: pad\n  }), guide && guide.y && /*#__PURE__*/React.createElement(YGuide, {\n    guide: guide,\n    pad: pad\n  }), charts.map(function (_ref9, i) {\n    var prop = _ref9.property,\n        type = _ref9.type,\n        x = _ref9.x,\n        y = _ref9.y,\n        chartRest = _objectWithoutPropertiesLoose(_ref9, _excluded2); // When we offset, we increase the padding on the end for all charts\n    // by the same amount and we shift each successive chart to the\n    // right by an offset for that chart. The last chart's right side\n    // will end up aligning with where the charts would have been\n    // had we not padded their ends.\n\n\n    var chartPad = offsetPad ? _extends({}, pad, {\n      end: offsetPad\n    }) : pad;\n    var offsetProps = offsetPad ? {\n      style: {\n        transform: \"translate(\" + offsets[i] + \"px, 0px)\"\n      }\n    } : {};\n\n    if (stackedChartType[type]) {\n      // reverse to ensure area Charts are stacked in the right order\n      return prop.map(function (cProp, j) {\n        var pProp = cProp.property || cProp;\n\n        var _ref10 = typeof cProp === 'object' ? cProp : {},\n            property = _ref10.property,\n            propRest = _objectWithoutPropertiesLoose(_ref10, _excluded3);\n\n        return /*#__PURE__*/React.createElement(Chart // eslint-disable-next-line react/no-array-index-key\n        , _extends({\n          key: j // when property name isn't valid, send empty array\n          ,\n          values: chartValues[i][j] || [],\n          overflow: true\n        }, seriesStyles[pProp], chartProps[i], chartRest, propRest, offsetProps, {\n          type: stackedChartType[type] || type,\n          size: size,\n          pad: chartPad\n        }));\n      }).reverse();\n    }\n\n    return /*#__PURE__*/React.createElement(Chart // eslint-disable-next-line react/no-array-index-key\n    , _extends({\n      key: i,\n      values: chartValues[i],\n      overflow: true\n    }, seriesStyles[prop], chartProps[i], chartRest, offsetProps, {\n      type: type,\n      size: size,\n      pad: chartPad\n    }));\n  }), placeholder && (typeof placeholder === 'string' && /*#__PURE__*/React.createElement(Box, {\n    fill: \"vertical\",\n    align: \"center\",\n    justify: \"center\",\n    background: {\n      color: 'background-front',\n      opacity: 'strong'\n    },\n    margin: pad\n  }, /*#__PURE__*/React.createElement(Text, {\n    color: \"text-weak\"\n  }, placeholder)) || placeholder), detail && /*#__PURE__*/React.createElement(Detail, {\n    activeProperty: activeProperty,\n    axis: axis,\n    data: data,\n    pad: pad,\n    series: series,\n    seriesStyles: seriesStyles,\n    renderValue: renderValue,\n    thickness: segmentThickness\n  }));\n  var legendElement = legend ? /*#__PURE__*/React.createElement(Legend, {\n    series: series,\n    seriesStyles: seriesStyles,\n    activeProperty: activeProperty,\n    setActiveProperty: setActiveProperty\n  }) : null;\n  var content = /*#__PURE__*/React.createElement(Grid, _extends({\n    ref: ref,\n    \"aria-label\": a11yTitle,\n    fill: stackFill,\n    columns: ['auto', stackFill === true || stackFill === 'horizontal' ? 'flex' : 'auto'],\n    rows: [stackFill === true || stackFill === 'vertical' ? 'flex' : 'auto', 'auto'],\n    areas: [{\n      name: 'yAxis',\n      start: [0, 0],\n      end: [0, 0]\n    }, {\n      name: 'xAxis',\n      start: [1, 1],\n      end: [1, 1]\n    }, {\n      name: 'charts',\n      start: [1, 0],\n      end: [1, 0]\n    }],\n    gap: gap\n  }, rest), xAxisElement, yAxisElement, stackElement);\n\n  if (legendElement) {\n    content = /*#__PURE__*/React.createElement(Box, {\n      align: \"start\"\n    }, content, legendElement);\n  }\n\n  return content;\n});\nDataChart.displayName = 'DataChart';\nDataChart.propTypes = DataChartPropTypes;\nexport { DataChart };","map":null,"metadata":{},"sourceType":"module"}